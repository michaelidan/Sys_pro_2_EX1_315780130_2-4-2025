# מטלה 1: מימוש גרף ואלגוריתמים 

**שם:** מיכאל עידן
**מייל:** michael9090124@gmail.com
**ת.ז.:** 315780130 

## תיאור הפרויקט

פרויקט זה מממש מבנה נתונים של גרף לא מכוון ממושקל באמצעות רשימת שכנויות (Adjacency List) בשפת C++.
המימוש נעשה **ללא שימוש בספרייה הסטנדרטית של C++ (STL)**, ובפרט ללא שימוש במכלים סטנדרטיים כמו `std::vector`, `std::queue` וכו'. כל מבני הנתונים הנדרשים (תור, תור עדיפויות, Union-Find) מומשו מאפס כחלק מהפרויקט.

הפרויקט כולל גם מימוש של אלגוריתמי גרפים נפוצים הפועלים על מבנה הגרף שנבנה:
* BFS (Breadth-First Search)
* DFS (Depth-First Search)
* Dijkstra's Algorithm (למציאת מסלולים קצרים ביותר מנקודת מקור)
* Prim's Algorithm (למציאת עץ פורש מינימלי)
* Kruskal's Algorithm (למציאת עץ פורש מינימלי)

הפרויקט כולל גם קובץ הדגמה (`main.cpp`) ובדיקות יחידה (`tests.cpp`) המבוססות על ספריית `doctest`.

## מבנה קבצים ומחלקות

הקוד מאורגן במספר קבצים ומחלקות, כולם תחת מרחב השמות (namespace) `graph`:

* **`Graph.h` / `Graph.cpp`:**
    * מכיל את מחלקת `Graph`.
    * אחראית על ייצוג הגרף באמצעות רשימת שכנויות (ממומשת עם מערכים דינמיים).
    * מספקת פונקציות להוספה והסרה של קשתות לא מכוונות (`addEdge`, `removeEdge`) והדפסת הגרף (`print_graph`).
    * מספר הקודקודים נקבע בבנייה ולא ניתן לשינוי.

* **`DataStructures.h` / `DataStructures.cpp`:**
    * מכיל מימושים בסיסיים (ללא דרישות סיבוכיות מחמירות) של מבני הנתונים הנדרשים לאלגוריתמים:
        * `Queue`: תור פשוט מבוסס מערך דינמי (מעגלי).
        * `PriorityQueue`: תור עדיפויות (מינימום) מבוסס מערך דינמי לא ממוין (עם חיפוש לינארי לשליפה).
        * `UnionFind`: מבנה נתונים של איחוד-מציאה (Disjoint Set Union) עם אופטימיזציות (איחוד לפי דרגה ודחיסת נתיבים).

* **`Algorithms.h` / `Algorithms.cpp`:**
    * מכיל את מחלקת `Algorithms`.
    * מקבלת בבנאי הפניה לאובייקט `Graph`.
    * מספקת מימושים של האלגוריתמים שצוינו לעיל (BFS, DFS, Dijkstra, Prim, Kruskal), המחזירים גרף חדש המייצג את התוצאה (עץ סריקה, עץ מסלולים קצרים, עץ פורש מינימלי).

* **`main.cpp`:**
    * קובץ הרצה ראשי המדגים יצירת גרף ושימוש באלגוריתמים השונים על מספר דוגמאות.

* **`tests.cpp`:**
    * מכיל בדיקות יחידה (unit tests) עבור המחלקות `Graph` ו-`Algorithms` באמצעות ספריית `doctest`.

* **`doctest.h`:**
    * קובץ הכותרת של ספריית הבדיקות `doctest` (יש להוריד בנפרד).

* **`Makefile`:**
    * קובץ הוראות לבנייה והרצה של הפרויקט באמצעות כלי `make` (או `mingw32-make`).

## בנייה והרצה (באמצעות Makefile)

ודא שכלי `make` (או `mingw32-make` אם אתה משתמש ב-MinGW מ-Strawberry Perl) זמין בטרמינל שלך. פתח טרמינל בתיקיית הפרויקט והשתמש בפקודות הבאות:

* **`mingw32-make`** (או `make`): בונה גם את התוכנית הראשית (`main.exe`) וגם את הרצת הבדיקות (`runTests.exe`).
* **`mingw32-make Main`**: בונה ומריץ את התוכנית הראשית (`main.exe`).
* **`mingw32-make test`**: בונה ומריץ את בדיקות היחידה (`runTests.exe`).
* **`mingw32-make clean`**: מוחק את קבצי ההרצה (`.exe`) וקבצי האובייקט (`.o`) שנוצרו.

## הרצת Valgrind (בסביבת לינוקס)

המטלה דורשת בדיקת דליפות זיכרון באמצעות `valgrind`. כלי זה זמין רק בסביבות לינוקס (כמו WSL). אם אתה עובד בסביבה כזו ו-`valgrind` מותקן:

1.  קמפל את הקוד **בסביבת לינוקס** באמצעות ה-`Makefile`.
2.  הרץ את הפקודה: `make valgrind`
    היא תריץ את `main.exe` דרך `valgrind` עם בדיקת דליפות מלאה.

## תלויות

* מהדר C++ התומך בתקן C++17 (למשל, g++).
* כלי `make` (או `mingw32-make`).
* קובץ הכותרת `doctest.h` (יש להוריד מ-GitHub).

## הערות נוספות / בעיות ידועות

* המימוש של תור העדיפויות (PriorityQueue) הוא בסיסי ולא יעיל (חיפוש לינארי), בהתאם לדרישות המטלה שלא התמקדו בסיבוכיות מבני הנתונים.
* המיון באלגוריתם Kruskal ממומש באמצעות Bubble Sort הפשוט והלא יעיל.
* במהלך הקומפילציה עם דגל `-Wall`, תופיע אזהרה על משתנה לא משומש (`originalU`) בפונקציה `kruskal` - זו אזהרה ידועה ולא קריטית.
